# In the beginning, there was the Assembly

First, thank you for taking the time to read my book! I want to point out that Engilsh is not my first language and you're welcome to provide feedback for grammatical errors you may find. Please see the DISCUSSION menu in the gitbook repository on the github.com web site.


In the Beginning of the computer world, there is a Word. It's the Assembly language.  
It's so close to the machine that it's hard to call it a language.
But it's a weird language and it's not simply binary code with 0's and 1's.
The assembly exists since the beginning.
Since the assembly language is very close to the machine language, it's possible to control computer behavior in a very specific manner.
Therefore learning the assembly language is more like learning how to speak directly to the computer hardware than compared with programming.  
Studying computer itself helps us to figure out how every programming language works on a computer.
And you can see the principles common to all programming languages.  
So I'm sure, you will be able to see programs as assembly code as just like [Neo](https://en.wikipedia.org/wiki/Neo_(The_Matrix)) was able to see the world as code.
It's really fun.  
You will discover the new world inside of the computer is actuall composed of many layers which will allow you to see very deep into the world of computers.
Learning assembly is like visiting new world because it makes you have an ability to understand and handle the complexities of a modern computer.
I cannot say that you would be super programmer if you know the assembly.  
But the excitement I felt when I first knew the assembly led me to the another world, Linux kernel and computer architecture. 
But the moment of when I saw the inside of computer after learning assembly drived me to the Linux kernel and computer architecture.
I want more people to have the chance to see the other aspect of the computer world.

I want to be like [_Morpheus](https://en.wikipedia.org/wiki/Morpheus_(The_Matrix)) who gave the Red Pill to Neo_ ;-\)



# Table of contents

* [intro\_emu8086](introemu8086.md)
* [number](number.md)
* [8086\_arch](8086arch.md)
* [mov](mov.md)
* [memory\_read\_write](memoryreadwrite.md)
* [addressing](addressing.md)
* [use\_mov](usemov.md)
* [variable](variable.md)
* [array](array.md)
* [pointer](pointer.md)
* [why\_assembly](whyassembly.md)
* [logic\_operation](logicoperation.md)
* [add\_sub\_mul](addsubmul.md)
* [div](div.md)
* [inc\_dec](incdec.md)
* [jump](jump.md)
* [conditional\_jump](conditionaljump.md)
* [compare](compare.md)
* [repeat](repeat.md)
* [stack](stack.md)
* [function](function.md)
* [function\_calling](functioncalling.md)
* [macro\_func](macrofunc.md)
* [howto\_emu8086.inc](howtoemu8086inc.md)
* [go\_further](gofurther.md)



