# 태초의 프로그래밍 언어 어셈블리

컴퓨터 세계의 태초에 말씀이 있었으니 어셈블리 언어입니다.
프로그래밍 언어라기에는 너무 컴퓨터에 가까워서 언어라고 하기 어렵고
그렇다고 0과 1로 이루어진 컴퓨터 신호도 아닌 이상한 언어입니다.
태초의 언어이므로 컴퓨터의 세부적인 동작 하나하나를 직접 지시할 수 있습니다.
그렇기 어셈블리 언어를 배운다는 것은 프로그래밍을 배운다기보다는
컴퓨터 그 자체를 배우는 것에 가깝습니다.
그런데 그렇게 컴퓨터 그 자체를 배우다보면 세상 모든 프로그래밍 언어가
어떤 원리로 돌아가는지 알게됩니다.
마치 매트릭스 세계에서 네오가 세상을 코드로 보는 것처럼
컴퓨터 세상의 모든게 어셈블리 기호들로 보이기 시작합니다.
그래서 너무나 재밌습니다.
복잡한 컴퓨터 세상을 이루는 원리들이 눈에 보인다는 것은 새로운 세상이 열리는것 같지요.


어셈블리 언어를 배우면 프로그래밍을 더 잘하거나 실력이 좋아진다는 말은 못합니다.
저부터가 프로그래밍을 잘하거나 뛰어난 개발자가 아니기 때문입니다.
그래도 처음 어셈블리 언어를 배우고 컴퓨터 세상에 대해 새롭게 눈뜬 순간의 흥분은
아직도 저를 이끌어서 리눅스 커널과 컴퓨터 구조를 공부하게 만들고 있습니다.
많은 분들이 세상을 다르게 볼 수 있는 기회를 가지셨으면 합니다.

참고로 나중에 기회가 되면 어셈블리와는 완전히 반대로 완전히 추상적인 언어인 LISP에 대해서도
글을 쓰게 되길 바랍니다. 어셈블리로 컴퓨터 세상에 대한 눈을 떴다면
LISP을 공부한 후로는 컴퓨터 세상과 실제 우리가 사는 세상을 하나로 볼 수 있게 되었습니다.

# Table of contents

* [Introduction](README.md)
* [intro\_emu8086](introemu8086.md)
* [number](number.md)
* [8086\_arch](8086arch.md)
* [mov](mov.md)
* [memory\_read\_write](memoryreadwrite.md)
* [addressing](addressing.md)
* [use\_mov](usemov.md)
* [variable](variable.md)
* [array](array.md)
* [pointer](pointer.md)
* [why\_assembly](whyassembly.md)
* [logic\_operation](logicoperation.md)
* [add\_sub\_mul](addsubmul.md)
* [div](div.md)
* [inc\_dec](incdec.md)
* [jump](jump.md)
* [conditional\_jump](conditionaljump.md)
* [compare](compare.md)
* [repeat](repeat.md)
* [stack](stack.md)
* [function](function.md)
* [function\_calling](functioncalling.md)
* [bios\_interrupt](biosinterrupt.md)
* [macro\_func](macrofunc.md)
* [howto\_emu8086.inc](howtoemu8086inc.md)
* [go\_further](gofurther.md)
